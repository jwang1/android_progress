
7/16/2017 (Sunday) 


	Android's :  Activity ,  Service ,  Receiver , ContentProvider


1. Chapter 1 (Activity)

   onCreate -> onStart -> onResume -> run -> onPause -> onStop -> onRestart (back to onStart) or onDestroy (go to destroy)


   My take on these:  onStart (not necessary showing the activity on screen yet);  onResume can show  (need to come back to revisit it)


   TODO:  need to write that Demo, to show 2 activities sequence ...

       
	   Completed it on 7/22/17 (Sat) https://github.com/jwang1/onPauseCalledBeforeAnotherActivityOnResume


7/20/17 (Thursday)

1. revisit Activity

   think of activity on the phone :   onCreate -- the activity is in mem and CPU now;   onStart -- the activity is warming up, but not visible yet;   onResume -- the activity is on screen now.



    so,  "onStart" vs "onResume" :  onResume activity is on Screen;  but onStart is not yet, almost there.    Think of the phone :  memory,  back of display, front of display  ---  |->|->|   so, onCreate (on memory), onStart (back of screen), onResume (front display) ...


   	1.1  onPause of an Activity must be executed, before another activity's onResume ...

	1.2  when user's back to previous activity:  onRestart -> onStart -> onResume  executed

	1.3  when user switch to home or another activity;  previous activity's onPause -> onStop executed .

	1.4  when user click "back" soft button;  onPause -> onStop -> onDestroy

	1.5  should NOT do heavy work in onPause, because the next Activity's onResume cannot start until previous Activity's onPause completes


7/21/17 (Friday)

TODO:  

  *) Chapter 1, P6  example, how to make 2 activities swap, ie, one activity goes out, and the other comes in, to show the 1st activity's onPause is called before 2nd activity's onResume .

      "how to" part,  perhaps create 2 apps ?   or, can we have 2 activities in one app, and do the switch ? <--  should be, for instance : 
	    a) create one activity with all todo list
		b) once click a todo item, go to the Details of the item.

	Did this before when creating the Movie review app, forgot it now,   <== Completed this on Saturday, in one App, created 2 activites (like Todo List;  and todoItem  two activities; and use Intent to startActivity;  and added onPause and onResume overrided methods simply for comments)


	***   Completed it on 7/22/17 (Sat) https://github.com/jwang1/onPauseCalledBeforeAnotherActivityOnResume


7/22/17 (Saturday)

  1. working on TODOs from 7/21

  2. About Activities Priorities :  Activity showing on screen and user can interact with it  -->  Activity on front but not able to interact with users (for instance, the activitiy is front, but it has a dialog up, hence, user cannot interact with the activity, but the dialog)   -->  Activity not on screen 

  3.  Activity Priorities :  activites killed when out of resources

  4.  Activity LaunchMode !  --- important topic

		standard

		singleTop

		singleTask

		singleInstance



 5.  IntentFilter  matching ...

       action matching

	   category matching

	   data matching



7/22/17 (Satureday)

 Chapter 2 : IPC

 1. Binder


 2. Socket


 3. android:process

    *) can only be defined from Manifest file;

	*) process-name starts with  ':' character, means 'private process'

	                       not start ':',  means the 'shared process' 

    *) SHARED DATA !!!

	   the threading-synchronized may not working in processes-shared-data ...

		
	
		Inter-Process mechanism : 

			a) Intent passing data

			b) shared files

			c) SharedPreferences

			d) Binder Messenger

			e) AIDL

			-) ContentProvider

			f) Socket  (the Kernel level, Linux sys) and ...

			g) old days: I tried Pipe, socket, almost the shared memory (but just stopped at the analysis)


		Data-passing:

		    a) serializable

				serialVersionUID --   if old objection has value 1L ;   the new class has value 2L,  and then,  (Serialized-Class) ObjectInputStream(FileInputStream("serialized-obj"))  will not work.


				if not set serialVersionUID in the class, deserialization will calculate hashCode from the object, and assign it to serialVersionUID.  Now, if class's new field or field-deleted, the hashCode will be different for the obj serialized before class change which also not serialVersionUID set.   Then, the deserialization going to fail.


			b) Parcelable

			   In android apps, use Parcelable is better than Serializable; usage wise Parcelable is a little more typings; but i/o expense is small, and faster.



			c) Binder  <--- Chapter 2 (p52)

				  *)  AIDL (Android Interface Definition Language ? )  -  also uses package, but still different from existing other Java classes.

							describe the interface methods (similar to RMI's methods? webmethods ? )  getBookList  and addBook defined in IBookManager.aidl

					*)  auto generated coe IBookManager.java from IBookManager.aidl file

							IBookManager includes Stub class which is used for anything transmit in the same process
							                      Proxy class for transmit in Different Processes.

					

					    in case of two processes communication (IPC) using Binder;  the flow (cycle):

							     Client -> Binder -> Service (onTransact) -> thread-pool -> reply -> Binder -> Client


					*)  we can write Binder without AIDL file;  the AIDL file is used to generate Binder class.

					      note the android.os.IInterface  

												 IBinder::transact


					*) Binder death (remote side terminated)   -- set some callback to notify service so that it can handle Binder death.

							IBinder::linkToDeath   IBinder::unlinkToDeath 



			d) Sharing with files :   process-1 writes to a file;   and process-2 reads from that file.


			       now, if both write to the file, the shared-file can be problem .



			e) SharedPreferences

						data saved in /data/data/package-name/shared_prefs  directory

						the data can be lost, not recommended for IPC data sharing.



			f) Messenger

					it's built on AIDL, light-weight IPC :

						i. service layer :  MessengerService extends Service
						ii. client side  :  MessengerHandler extends Handler


			g) AIDL 

						supports :  primirary types (int, long, char, boolean, double etc)
						            String and CharSequence
												List (only ArrayList and all its elements have to be supported by AIDL)
												Map (only HashMap and all its elements have to be supported by AIDL)
												Parcelable  (any objs implements Parcelable interface)
												AIDL 


						



				binder pool 

				  Binder mBinderPool = new BinderPool.BinderpoolImpl();



	*) ContentProvider (built on top of Binder)


	*) Socket 


		need permissions

		<uses-permission android:name="android.permission.INTERNET" />
		<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />


		TcpServer -  
		
			svrSckt = new ServerSocket(18001);

			final Socket client = svrSckt.accept();

			new Thread() { 
				@Override
				public void run() {
					responseClient(client);
				}
			}.start();

			void responseClient(Socket sckt) {
				.
				.
				.
			}





 4. android:thread


 7/27/17 (Thr) -  P121 ICP comparison -  

 	bundler vs Shared-file vs AIDL vs Messenger vs ContentProvider vs Socket 

	
		BinderPool 



7/31/17 (Monday) 

   *) Completed reading "Android from scratch to master" -

      there are some good stuff, the structure is very clear, and learned quite a lot;  

	  worth of reading again;  and the Final Project is good.



   *) watched 李宏毅's ML,  the 2'51" of https://www.youtube.com/watch?v=IzHoNwlCGnE&list=PLJV_el3uVTsPMxPbjeX7PicgWbY7F8wW9 is very helpful,

       watched "https://www.youtube.com/watch?v=IzHoNwlCGnE&list=PLJV_el3uVTsPMxPbjeX7PicgWbY7F8wW9"  (brief introduction of Deep Learning - very helpful on concept ,  history, simple, slow are better)

	   watched "https://www.youtube.com/watch?v=FrKWiRv254g&list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49&index=10" (CNN - Convolutional Neuro network) it's good, clearly explained CNN

	   ==> TODO:  to watch the 2 videos of RNN (Recurrant Neuro Network)  --- links from Mr's Li's channel !



8/1/17 (Tue) 

View and event handling

  when an event raised, it goes through 
  				Activity->Window->View 

  If view's onTouchEvent returns "false", ie, not handling such event, and then it will bubble up to Window, if still not handled, and then bubble up to Activity to be handled.  (similar to emergency handling, worker handles it first, if not able to, and then pass up to supervisor...) 


    1. one touch event, 

	   *)  boolean dispatchTouchEvent(MotionEvent ev)

	   			"dispatch", if event dispatched to current-View, this method is called; and returns current-View's onTouchEvent and child view's dispatchTouchEvent method's value.

	   *)  boolean onInterceptTouchEvent(MotionEvent ev)

	   			"used inside view's dispatchTouchEvent method - ie the above one", 

	   *) boolean onTouchEvent(MotionEvent ev)


				used in dispatchTouchEvent method; used to handle that event, 


	In summary, 

		public boolean dispatchTouchEvent(MotionEvent ev) {
			boolean consume = false;

			if (onInterceptTouchEvent(ev)) {
				consume = onTouchEvent(ev);
			} else {
				consume = child.dispatchTouchEvent(ev);		// notice the child 
			}

			return consume;

		}








